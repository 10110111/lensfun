#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.
"""

import os, argparse, sys, re, copy
from xml.etree import ElementTree


parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                    help="""path to the LCP files (default: ".")""")
parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                    help="path of output file (default: ~/.local/share/lensfun/_lcps.xml)")
parser.add_argument("--db-path", help="Path to the lensfun database.  If not given, look in the same places as Lensfun.")
parser.add_argument("--prefer-lcp", action="store_true", help="Prefer LCP data over Lensfun data.")
args = parser.parse_args()


def indent(elem, level=0):
    """Indent the output ElementTree in-place by added whitespace so that it looks
    nicer in the flattened output.  Taken from the ElementTree webseite.  It
    was modified so that it produces even nicer output for Lensfun files.

    :param elem: the root element of an ElementTree tree
    :param level: the indentation level of the root element, in numbers of space
        characters.

    :type elem: xml.etree.ElementTree.Element
    :type level: int

    :return:
      The same tree but with added whitespace in its ``text`` and ``tail``
      attributes.

    :rtype: xml.etree.ElementTree.Element
    """
    i = "\n" + level * "    "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "    "
        for elem in elem:
            indent(elem, level + 1)
            if level == 0:
                elem.tail = "\n" + i + "    "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


class Camera:

    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None


def child_without_attributes(parent, name):
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child


class Lens:
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")

    def __init__(self, element):
        self.element = element
        model = child_without_attributes(element, "model").text
        self.normalized_model = self.normalize_lens_model_name(model)
        self.cropfactor = float(element.find("cropfactor").text)
        first_mount = element.find("mount").text
        if first_mount[0].islower():
            self.fixed_lens_mount = first_mount
        else:
            self.fixed_lens_mount = None
        self.chdk = "chdk" in model.lower()

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in Lens.model_name_token_regex.findall(name.lower())
                     if token != "f" and not token.isspace() and
                     (len(token) > 1 or token.isalnum() or token in "*+"))

    def matches(self, names, cropfactor, fixed_lens_mount):
        if self.fixed_lens_mount and fixed_lens_mount == self.fixed_lens_mount and not self.chdk:
            return True
        if cropfactor and not 0.96 < cropfactor / self.cropfactor < 1.041:
            return False
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            if len(normalized_model) < 4:
                return True
        return False

    def __hash__(self):
        return hash(self.normalized_model) ^ hash(self.cropfactor)

    def __eq__(self, other):
        return self.normalized_model == other.normalized_model and self.cropfactor == other.cropfactor


cameras = {}
lenses = set()
def crawl_directory(dirpath):
    for root, __, filenames in os.walk(dirpath):
        for filename in filenames:
            if not filename.startswith("_") and filename.endswith(".xml"):
                tree = ElementTree.parse(os.path.join(root, filename)).getroot()
                for element in tree.findall("camera"):
                    maker, model = child_without_attributes(element, "maker").text, \
                                   child_without_attributes(element, "model").text
                    cameras[maker.lower(), model.lower()] = camera = Camera(maker, model)
                    camera.cropfactor = float(element.find("cropfactor").text)
                    camera.mount = element.find("mount").text
                lenses.update(Lens(element) for element in tree.findall("lens"))

paths_search_list = [args.db_path] if args.db_path else \
                    ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun",
                     os.path.expanduser("~/.local/share/lensfun/updates"),
                     os.path.expanduser("~/.local/share/lensfun")]
for path in paths_search_list:
    crawl_directory(path)
if not cameras:
    print("Warning: No Lensfun database found.")


class FieldNotFoundError(Exception):
    pass


class NoLCPDataUsed(Exception):
    pass


class NoFieldDefault:
    pass


camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
unusable_lens_name_regex = re.compile(r"[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)
focal_length_regex = re.compile(r"([0-9.]+)\s*mm\b", re.IGNORECASE)


class LCPLens:

    compact_cameras = []

    def __init__(self, filepath):
        self.tree = ElementTree.parse(filepath)
        self.old_format = bool(
            self.tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in self.tree.getroot()[0][0][0][0]]
        self._read_first_entry()
        self._fix_focal_lengths()
        self.xml_element = self.xml_element()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def _fix_focal_lengths(self):
        """For now, I just delete entries with a missing FocalLength field."""
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                self.read_field(entry, "FocalLength")
            except FieldNotFoundError:
                match = focal_length_regex.search(self.model)
                focal_length = None
                if match:
                    focal_length = match.group(1)
                else:
                    try:
                        match = focal_length_regex.search(self.read_field(entry, "Lens"))
                    except FieldNotFoundError:
                        if "inspire 1 fc350" in self.model.lower():
                            focal_length = 20.7
                    else:
                        focal_length = match.group(1)
                if focal_length:
                    if self.old_format:
                        ElementTree.SubElement(entry, camera_ns + "FocalLength").text = focal_length
                        clean_entries.append(entry)
                    else:
                        entry.attrib[camera_ns + "FocalLength"] = focal_length
                        clean_entries.append(entry)
                else:
                    print("Warning: No focal length could be determined for {} / {}.".format(self.maker, self.model))
                    raise NoLCPDataUsed
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries

    @staticmethod
    def clean_lens_maker(model):
        model_lower = model.lower()
        if "pentax" in model_lower:
            return "Pentax"
        if model_lower.startswith("hero"):
            return "GoPro"
        if model_lower.startswith("iphone"):
            return "Apple"
        if model_lower.startswith("inspire"):
            return "DJI"
        if model_lower.startswith("schneider"):
            return "Schneider-Kreuznach"
        if model_lower.startswith("phase one"):
            return "Phase One"
        if model_lower.startswith("venus optics"):
            return "Venus Optics"
        if "mitakon" in model_lower:
            return "Mitakon"
        if "cgo2g" in model_lower:
            return "Yuneec"
        if model_lower.startswith("slr magic"):
            return "SLR Magic"
        if model_lower.startswith("dp") and "quattro" in model_lower:
            return "Sigma"
        if "voigtlander" in model_lower:
            return "VoigtlÃ¤nder"
        if "handevision" in model_lower:
            return "HandeVision"
        maker = model.split()[0].capitalize()
        return maker
            
    def _read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        self.camera_model = self.read_field(entry, "Model", camera_make)
        camera = cameras.get((camera_make.lower(), self.camera_model.lower()))
        self.model_en = self.read_field(entry, "LensPrettyName")
        if self.read_field(entry, "CameraRawProfile", "True").lower() == "false":
            self.model_en += " (JPEGs)"
            self.raw = False
        else:
            self.raw = True
        self.maker = self.clean_lens_maker(self.model_en)
        try:
            self.model = self.read_field(entry, "Lens")
        except FieldNotFoundError:
            self.model = self.model_en
        if unusable_lens_name_regex.match(self.model):
            self.model = self.model_en
#        print(self.model_en, (50 - len(self.model_en)) * " ", self.model)
        try:
            self.cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            self.cropfactor = camera and camera.cropfactor or 1
        self.fixed_lens_mount = None
        if camera:
            if camera.mount[0].islower():
                self.fixed_lens_mount = camera.mount
        elif re.search(r"coolpix|finefix|powershot|sony dsc|cyber-?shot|apple|iphone|hero|inspire|cgo2gb|samsung ex1",
                       self.model_en, re.IGNORECASE):
            self.fixed_lens_mount = "compactCamera" + str(abs(hash(self.model_en)))
            camera_element = ElementTree.Element("camera")
            ElementTree.SubElement(camera_element, "maker").text = camera_make
            ElementTree.SubElement(camera_element, "model").text = self.camera_model
            ElementTree.SubElement(camera_element, "mount").text = self.fixed_lens_mount
            ElementTree.SubElement(camera_element, "cropfactor").text = str(self.cropfactor)
            self.compact_cameras.append(camera_element)
        models = [self.model] if self.model == self.model_en else [self.model, self.model_en]
        for lens in lenses:
            if lens.matches(models, self.cropfactor, self.fixed_lens_mount):
                self.lensfun_lens = lens
                self.maker = child_without_attributes(lens.element, "maker").text
                self.model = child_without_attributes(lens.element, "model").text
                break
        else:
            self.lensfun_lens = None
        
    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    def best_entries(self, tca):
        """Return the entries best suited for distortion and TCA data, because Lensfun
        can only use one per focal length."""
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).\
               find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -2)
            current_aperture = current_apertures.setdefault(focal_length, 1001)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("distortion", {"focal": str(focal_length), "model": "acm"})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("tca", {"focal": str(focal_length), "model": "acm"})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else
                                                            "ChromaticBlueGreenModel"))
                scale_factor = self.read_field(chromatic_element, "ScaleFactor", None)
                if scale_factor is not None:
                    element.attrib[type_ + "0"] = scale_factor
                for i in range(1, 6):
                    parameter = self.read_field(chromatic_element, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        match = re.search(r"f/?(?P<min>[0-9.]+)", self.model, re.IGNORECASE)
        if match:
            aperture_min = float(match.group("min"))
        else:
            aperture_min = 0
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue", "nan"))
            distance = float(self.read_field(entry, "FocusDistance", "nan"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            focal_length = self.read_field(entry, "FocalLength")
            try:
                aperture = self.read_field(entry, "ApertureValue")
                distance = self.read_field(entry, "FocusDistance")
            except FieldNotFoundError:
                continue
            if aperture_min > float(aperture):
                continue
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = self.get_description_element_maybe(entry)
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    entry = self.get_description_element_maybe(entry)
                    element = ElementTree.Element("vignetting", {"focal": focal_length, "model": "acm", "aperture": aperture,
                                                                 "distance": distance})
                    for i in range(1, 6):
                        Î± = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if Î± is not None:
                            element.attrib["alpha{}".format(i)] = Î±
                    elements.append(element)
        return elements

    def guess_ilc_mounts(self):
        mounts = set()
        if self.maker == "Nikon":
            if 2.6 < self.cropfactor < 2.8:
                mounts.add("Nikon CX")
            else:
                mounts.add("Nikon F AF")
        elif self.maker == "Canon":
            if "ef-m" in self.model.lower():
                mounts.add("Canon EF-M")
            else:
                mounts.add("Canon EF")
        elif self.maker == "Sony":
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.add("Sony Alpha")
        elif self.maker == "Pentax":
            mounts.add("Pentax KAF")
        elif self.maker == "Sigma":
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.update({"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD",
                               "Olympus OM", "4/3 System"})
        elif self.maker == "Zeiss":
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.update({"Nikon F AF", "Fujifilm X", "Canon EF", "Leica M"})
        elif self.maker == "VoigtlÃ¤nder":
            mounts.update({"DKL", "Leica M", "M42", "Micro 4/3 System", "Nikon F"})
        elif self.maker == "Leica":
            if "-S " in self.model or " S " in self.model:
                mounts.add("Leica S")
            elif "-R " in self.model or " R " in self.model:
                mounts.add("Leica R")
            else:
                mounts.add("Leica M")
        elif self.maker == "Mamiya":
            mounts.add("Mamiya 645")
        elif self.maker == "Tokina":
            mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Canon FD", "Minolta M", "Olympus OM"})
        elif self.maker == "Tamron":
            mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Samsung":
            if "NX" in self.model or "NX" in self.camera_model:
                mounts.add("Samsung NX")
        elif self.maker == "HandeVision":
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.update({"Canon EF-M", "Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "SLR Magic":
            mounts.update({"Leica M", "Sony E", "Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "Hasselblad":
            if "LF" in self.model:
                mounts.add("Sony E")
            else:
                mounts.add("Hasselblad H")
        elif self.maker == "Mitakon":
            mounts.update({"Sony E", "Micro 4/3 System", "Fujifilm X", "Canon EF", "Nikon F AI"})
        elif self.maker == "Venus Optics":
            mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Schneider-Kreuznach":
            if "phase one" in self.camera_model.lower():
                mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Phase One":
            mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Lomography":
            mounts.update({"Nikon F AF", "Canon EF"})
        if not mounts:
            print("Warning: Fall back to default mounts for {} / {}.".format(self.maker, self.model))
            mounts = {"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD",
                      "Olympus OM", "4/3 System"}
        result = []
        for mount in mounts:
            element = ElementTree.Element("mount")
            element.text = mount
            result.append(element)
        return result

    def xml_element(self):
        if self.lensfun_lens:
            lens = copy.deepcopy(self.lensfun_lens.element)
            calibration = lens.find("calibration")
            if calibration is None:
                calibration = ElementTree.SubElement(lens, "calibration")
            lcp_entries_used = False
            if calibration.find("distortion") is None or args.prefer_lcp:
                entries, fisheye = self.generate_distortion_entries()
                if entries:
                    type_ = lens.find("type")
                    if fisheye:
                        if type_ is not None:
                            type_.text = "fisheye"
                        else:
                            type_element = ElementTree.Element("type")
                            type_element.text = "fisheye"
                            lens.insert(max(len(lens) - 1, 0), type_element)
                    elif type_ is not None:
                        lens.remove(type_)
                    for entry in calibration.findall("distortion"):
                        calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("tca") is None or args.prefer_lcp:
                entries = self.generate_tca_entries()
                if entries:
                    for entry in calibration.findall("tca"):
                        calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("vignetting") is None or args.prefer_lcp:
                entries = self.generate_vignetting_entries()
                if entries:
                    for entry in calibration.findall("vignetting"):
                        calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if not lcp_entries_used:
                raise NoLCPDataUsed
        else:
            lens = ElementTree.Element("lens")
            ElementTree.SubElement(lens, "maker").text = self.maker
            ElementTree.SubElement(lens, "model").text = self.model
            if self.fixed_lens_mount:
                suffix = "" if self.raw else " (JPEGs)"
                ElementTree.SubElement(lens, "model", lang="en").text = "fixed lens" + suffix
                ElementTree.SubElement(lens, "model", lang="de").text = "festes Objektiv" + suffix
                ElementTree.SubElement(lens, "mount").text = self.fixed_lens_mount
            else:
                if self.model != self.model_en:
                    ElementTree.SubElement(lens, "model", {"lang": "en"}).text = self.model_en
                lens.extend(self.guess_ilc_mounts())
            ElementTree.SubElement(lens, "cropfactor").text = str(self.cropfactor)
            entries, fisheye = self.generate_distortion_entries()
            if fisheye:
                ElementTree.SubElement(lens, "type").text = "fisheye"
            calibration = ElementTree.SubElement(lens, "calibration")
            if entries:
                calibration.extend(entries)
            entries = self.generate_tca_entries()
            if entries:
                calibration.extend(entries)
            entries = self.generate_vignetting_entries()
            if entries:
                calibration.extend(entries)
        self.correction_coverage = 0
        if calibration.find("distortion") is not None:
            self.correction_coverage += 1
        if calibration.find("tca") is not None:
            self.correction_coverage += 1
        if calibration.find("vignetting") is not None:
            self.correction_coverage += 1
        if not self.correction_coverage:
            print("Warning: LCP file for {} / {} contained no correction data.".format(self.maker, self.model))
            raise NoLCPDataUsed
        return lens

    @property
    def normalized_cropfactor(self):
        if 1.5 <= self.cropfactor <= 1.57:
            return 1.5
        elif 1.58 <= self.cropfactor <= 1.63:
            return 1.6
        elif 1.2 <= self.cropfactor <= 1.3:
            return 1.3
        else:
            return round(self.cropfactor * 10) / 10


lcp_lenses = {}
for root, __, filenames in os.walk(args.input_directory):
    for filename in filenames:
        filepath = os.path.join(root, filename)
        try:
            lcp_lens = LCPLens(filepath)
        except (ElementTree.ParseError, NoLCPDataUsed):
            continue
        key = (lcp_lens.maker, lcp_lens.model, lcp_lens.normalized_cropfactor)
        already_existing_lens = lcp_lenses.get(key)
        if not already_existing_lens or already_existing_lens.correction_coverage < lcp_lens.correction_coverage \
           or already_existing_lens.correction_coverage == lcp_lens.correction_coverage and \
           already_existing_lens.cropfactor > lcp_lens.cropfactor:
            lcp_lenses[key] = lcp_lens


output = ElementTree.Element("lensdatabase", {"version": "2"})
for camera in LCPLens.compact_cameras:
    output.append(camera)
for lens in lcp_lenses.values():
    output.append(lens.xml_element)
indent(output)
if len(output):
    output.text = "\n\n    "
    output.tail = "\n"
    output[-1].tail = "\n\n"
open(args.output, "w").write(ElementTree.tostring(output, encoding="unicode"))
