#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.
"""

import os, argparse, sys, re, copy
from xml.etree import ElementTree


parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                    help="""path to the LCP files (default: ".")""")
parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                    help="path of output file (default: ~/.local/share/lensfun/_lcps.xml)")
parser.add_argument("--db-path", help="Path to the lensfun database.  If not given, look in the same places as Lensfun.")
args = parser.parse_args()


def indent(elem, level=0):
    """Indent a given ElementTree in-place by added whitespace so that it looks
    nicer in the flattened output.  Taken from the ElementTree webseite.  This
    routine may be embedded directly into ElementTree in a future version of
    it.

    :param elem: the root element of an ElementTree tree
    :param level: the indentation level of the root element, in numbers of space
        characters.

    :type elem: xml.etree.ElementTree.Element
    :type level: int

    :return:
      The same tree but with added whitespace in its ``text`` and ``tail``
      attributes.

    :rtype: xml.etree.ElementTree.Element
    """
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        for elem in elem:
            indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


class Camera:

    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None


def child_without_attributes(parent, name):
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child


class Lens:
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")

    def __init__(self, element):
        self.element = element
        self.normalized_model = self.normalize_lens_model_name(child_without_attributes(element, "model").text)
        self.cropfactor = float(element.find("cropfactor").text)

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in Lens.model_name_token_regex.findall(name.lower())
                     if token != "f" and not token.isspace() and
                     (len(token) > 1 or token.isalnum() or token in "*+"))

    def matches(self, names, cropfactor):
        if cropfactor and not 0.96 < cropfactor / self.cropfactor < 1.041:
            return False
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            if len(normalized_model) < 4:
                return True
        return False

    def __hash__(self):
        return hash(self.normalized_model) ^ hash(self.cropfactor)

    def __eq__(self, other):
        return self.normalized_model == other.normalized_model and self.cropfactor == other.cropfactor


cameras = {}
lenses = set()
def crawl_directory(dirpath):
    for root, __, filenames in os.walk(dirpath):
        for filename in filenames:
            if filename.endswith(".xml"):
                tree = ElementTree.parse(os.path.join(root, filename)).getroot()
                for element in tree.findall("camera"):
                    maker, model = child_without_attributes(element, "maker").text, \
                                   child_without_attributes(element, "model").text
                    cameras[maker.lower(), model.lower()] = camera = Camera(maker, model)
                    camera.cropfactor = float(element.find("cropfactor").text)
                    camera.mount = element.find("mount").text
                lenses.update(Lens(element) for element in tree.findall("lens"))

paths_search_list = [args.db_path] if args.db_path else \
                    ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun",
                     os.path.expanduser("~/.local/share/lensfun/updates"),
                     os.path.expanduser("~/.local/share/lensfun")]
for path in paths_search_list:
    crawl_directory(path)
if not cameras:
    print("No Lensfun database found.")
    sys.exit(1)


class FieldNotFoundError(Exception):
    pass


class NoFieldDefault:
    pass


class LCPLens:

    def __init__(self, filepath):
        self.tree = ElementTree.parse(filepath)
        self.old_format = bool(
            self.tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in self.tree.getroot()[0][0][0][0]]
        self._read_first_entry()
        self._fix_focal_lengths()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def _fix_focal_lengths(self):
        """For now, I just delete entries with a missing FocalLength field."""
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                focal_length = float(self.read_field(entry, "FocalLength"))
            except FieldNotFoundError:
                print("Error!")
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries
            
    def _read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        camera_model = self.read_field(entry, "Model", camera_make)
        camera = cameras.get((camera_make.lower(), camera_model.lower()))
        self.model_en = self.read_field(entry, "LensPrettyName")
        try:
            self.model = self.read_field(entry, "Lens")
        except FieldNotFoundError:
            self.model = self.model_en
        if unusable_lens_name_regex.match(self.model):
            self.model = self.model_en
#        print(self.model_en, (50 - len(self.model_en)) * " ", self.model)
        try:
            self.cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            self.cropfactor = camera and camera.cropfactor or 1
        models = [self.model] if self.model == self.model_en else [self.model, self.model_en]
        for lens in lenses:
            if lens.matches(models, self.cropfactor):
                self.lensfun_lens = lens
#                print("Match! (1)")
                break
        else:
#            print("No Match! (2)")
            self.lensfun_lens = None
        
    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    def best_entries(self, tca):
        """Return the entries best suited for distortion and TCA data, because Lensfun
        can only use one per focal length."""
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).\
               find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -1)
            current_aperture = current_apertures.setdefault(focal_length, 1000)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("distortion", {"focal": str(focal_length), "model": "acm"})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("tca", {"focal": str(focal_length), "model": "acm"})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else
                                                            "ChromaticBlueGreenModel"))
                scale_factor = self.read_field(chromatic_element, "ScaleFactor", None)
                if scale_factor is not None:
                    element.attrib[type_ + "0"] = scale_factor
                for i in range(1, 6):
                    parameter = self.read_field(chromatic_element, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue", "nan"))
            distance = float(self.read_field(entry, "FocusDistance", "nan"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            focal_length = self.read_field(entry, "FocalLength")
            try:
                aperture = self.read_field(entry, "ApertureValue")
                distance = self.read_field(entry, "FocusDistance")
            except FieldNotFoundError:
                continue
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    element = ElementTree.Element("vignetting", {"focal": focal_length, "model": "acm", "aperture": aperture,
                                                                 "distance": distance})
                    for i in range(1, 6):
                        α = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if α is not None:
                            element.attrib["alpha{}".format(i)] = α
                    elements.append(element)
        return elements


camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
unusable_lens_name_regex = re.compile("[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)

output = ElementTree.Element("lensdatabase", {"version": "2"})
for root, __, filenames in os.walk(args.input_directory):
    for filename in filenames:
        filepath = os.path.join(root, filename)
        try:
            lcp_lens = LCPLens(filepath)
        except ElementTree.ParseError:
            continue
#        print(filepath)
        if lcp_lens.lensfun_lens:
            lens = copy.deepcopy(lcp_lens.lensfun_lens.element)
            calibration = lens.find("calibration")
            if calibration is None:
                calibration = ElementTree.SubElement(lens, "calibration")
            entries_generated = False
            if calibration.find("distortion") is None:
                entries = lcp_lens.generate_distortion_entries()[0]
                if entries:
                    calibration.extend(entries)
                    entries_generated = True
            if calibration.find("tca") is None:
                entries = lcp_lens.generate_tca_entries()
                if entries:
                    calibration.extend(entries)
                    entries_generated = True
            if calibration.find("vignetting") is None:
                entries = lcp_lens.generate_vignetting_entries()
                if entries:
                    calibration.extend(entries)
                    entries_generated = True
            if not entries_generated:
                continue
        else:
            lens = ElementTree.Element("lens")
            ElementTree.SubElement(lens, "model").text = lcp_lens.model
            if lcp_lens.model != lcp_lens.model_en:
                ElementTree.SubElement(lens, "model", {"lang": "en"}).text = lcp_lens.model_en
            ElementTree.SubElement(lens, "cropfactor").text = str(lcp_lens.cropfactor)
            calibration = ElementTree.SubElement(lens, "calibration")
            calibration.extend(lcp_lens.generate_distortion_entries()[0])
            calibration.extend(lcp_lens.generate_tca_entries())
            calibration.extend(lcp_lens.generate_vignetting_entries())
        output.append(lens)
indent(output)
open("/tmp/_adobe.xml", "w").write(ElementTree.tostring(output, encoding="unicode"))
