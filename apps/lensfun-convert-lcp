#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.
"""

import os, argparse, sys, re
from xml.etree import ElementTree


parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                    help="""path to the LCP files (default: ".")""")
parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                    help="path of output file (default: ~/.local/share/lensfun/_lcps.xml)")
parser.add_argument("--db-path", help="Path to the lensfun database.  If not given, look in the same places as Lensfun.")
args = parser.parse_args()


class Camera:

    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None


def child_without_attributes(parent, name):
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child


class Lens:
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")

    def __init__(self, element):
        self.element = element
        self.normalized_model = self.normalize_lens_model_name(child_without_attributes(element, "model").text)
        self.cropfactor = float(element.find("cropfactor").text)

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in Lens.model_name_token_regex.findall(name.lower())
                     if token != "f" and not token.isspace() and
                     (len(token) > 1 or token.isalnum() or token in "*+"))

    def matches(self, names, cropfactor):
        if cropfactor and not 0.96 < cropfactor / self.cropfactor < 1.041:
            return False
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            if len(normalized_model) < 4:
                return True
        return False

    def __hash__(self):
        return hash(self.normalized_model) ^ hash(self.cropfactor)

    def __eq__(self, other):
        return self.normalized_model == other.normalized_model and self.cropfactor == other.cropfactor


cameras = {}
lenses = set()
def crawl_directory(dirpath):
    for root, __, filenames in os.walk(dirpath):
        for filename in filenames:
            if filename.endswith(".xml"):
                tree = ElementTree.parse(os.path.join(root, filename)).getroot()
                for element in tree.findall("camera"):
                    maker, model = child_without_attributes(element, "maker").text, \
                                   child_without_attributes(element, "model").text
                    cameras[maker.lower(), model.lower()] = camera = Camera(maker, model)
                    camera.cropfactor = float(element.find("cropfactor").text)
                    camera.mount = element.find("mount").text
                lenses.update(Lens(element) for element in tree.findall("lens"))

paths_search_list = [args.db_path] if args.db_path else \
                    ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun",
                     os.path.expanduser("~/.local/share/lensfun/updates"),
                     os.path.expanduser("~/.local/share/lensfun")]
for path in paths_search_list:
    crawl_directory(path)
if not cameras:
    print("No Lensfun database found.")
    sys.exit(1)


class FieldNotFoundError(Exception):
    pass


class NoFieldDefault:
    pass


class LCPFile:

    def __init__(self, filepath):
        self.tree = ElementTree.parse(filepath)
        self.old_format = bool(
            self.tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in self.tree.getroot()[0][0][0][0]]
        self._read_first_entry()
        self._fix_focal_lengths()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def _fix_focal_lengths(self):
        """For now, I just delete entries with a missing FocalLength field."""
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                focal_length = float(self.read_field(entry, "FocalLength"))
            except FieldNotFoundError:
                print("Error!")
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries
            
    def _read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        camera_model = self.read_field(entry, "Model", camera_make)
        camera = cameras.get((camera_make.lower(), camera_model.lower()))
        model_en = self.read_field(entry, "LensPrettyName")
        try:
            model = self.read_field(entry, "Lens")
        except FieldNotFoundError:
            model = model_en
        if unusable_lens_name_regex.match(model):
            model = model_en
#                    print(model_en, (50 - len(model_en)) * " ", model)
        try:
            cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            cropfactor = camera and camera.cropfactor
        for lens in lenses:
            models = [model] if model == model_en else [model, model_en]
            if lens.matches(models, cropfactor):
#                print("Match! (1)")
                break
        else:
#            print("No Match! (2)")
            lens = None
        
    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    def best_entries(self, tca):
        """Return the entries best suited for distortion and TCA data, because Lensfun
        can only use one per focal length."""
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).\
               find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -1)
            current_aperture = current_apertures.setdefault(focal_length, 1000)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            element = ElementTree.Element("distortion", {"focal": str(focal_length)})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            element = ElementTree.Element("tca", {"focal": str(focal_length)})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else
                                                            "ChromaticBlueGreenModel"))
                for i in range(6):
                    parameter = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue"))
            distance = float(self.read_field(entry, "FocusDistance"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    focal_length = float(self.read_field(entry, "FocalLength"))
                    aperture = float(self.read_field(entry, "ApertureValue"))
                    distance = float(self.read_field(entry, "FocusDistance"))
                    element = ElementTree.Element("vignetting", {"focal": str(focal_length), "aperture": aperture,
                                                                 "distance": distance})
                    for i in range(1, 6):
                        α = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if α is not None:
                            element.attrib["alpha{}".format(i)] = α
                    elements.append(element)
        return elements


camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
unusable_lens_name_regex = re.compile("[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)

for root, __, filenames in os.walk(args.input_directory):
    for filename in filenames:
        filepath = os.path.join(root, filename)
        try:
            lcp_file = LCPFile(filepath)
        except ElementTree.ParseError:
            continue
        print(filepath)
        (len(lcp_file.generate_distortion_entries()))
