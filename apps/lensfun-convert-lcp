#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.
"""

import os, argparse, sys, re, copy
from xml.etree import ElementTree


parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                    help="""path to the LCP files (default: ".")""")
parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                    help="path of output file (default: ~/.local/share/lensfun/_lcps.xml)")
parser.add_argument("--db-path", help="Path to the lensfun database.  If not given, look in the same places as Lensfun.")
args = parser.parse_args()


def indent(elem, level=0):
    """Indent the output ElementTree in-place by added whitespace so that it looks
    nicer in the flattened output.  Taken from the ElementTree webseite.  It
    was modified so that it produces even nicer output for Lensfun files.

    :param elem: the root element of an ElementTree tree
    :param level: the indentation level of the root element, in numbers of space
        characters.

    :type elem: xml.etree.ElementTree.Element
    :type level: int

    :return:
      The same tree but with added whitespace in its ``text`` and ``tail``
      attributes.

    :rtype: xml.etree.ElementTree.Element
    """
    i = "\n" + level * "    "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "    "
        for elem in elem:
            indent(elem, level + 1)
            if level == 0:
                elem.tail = "\n" + i + "    "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


class Camera:

    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None


def child_without_attributes(parent, name):
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child


class Lens:
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")

    def __init__(self, element):
        self.element = element
        self.normalized_model = self.normalize_lens_model_name(child_without_attributes(element, "model").text)
        self.cropfactor = float(element.find("cropfactor").text)

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in Lens.model_name_token_regex.findall(name.lower())
                     if token != "f" and not token.isspace() and
                     (len(token) > 1 or token.isalnum() or token in "*+"))

    def matches(self, names, cropfactor):
        if cropfactor and not 0.96 < cropfactor / self.cropfactor < 1.041:
            return False
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            if len(normalized_model) < 4:
                return True
        return False

    def __hash__(self):
        return hash(self.normalized_model) ^ hash(self.cropfactor)

    def __eq__(self, other):
        return self.normalized_model == other.normalized_model and self.cropfactor == other.cropfactor


cameras = {}
lenses = set()
def crawl_directory(dirpath):
    for root, __, filenames in os.walk(dirpath):
        for filename in filenames:
            if not filename.startswith("_") and filename.endswith(".xml"):
                tree = ElementTree.parse(os.path.join(root, filename)).getroot()
                for element in tree.findall("camera"):
                    maker, model = child_without_attributes(element, "maker").text, \
                                   child_without_attributes(element, "model").text
                    cameras[maker.lower(), model.lower()] = camera = Camera(maker, model)
                    camera.cropfactor = float(element.find("cropfactor").text)
                    camera.mount = element.find("mount").text
                lenses.update(Lens(element) for element in tree.findall("lens"))

paths_search_list = [args.db_path] if args.db_path else \
                    ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun",
                     os.path.expanduser("~/.local/share/lensfun/updates"),
                     os.path.expanduser("~/.local/share/lensfun")]
for path in paths_search_list:
    crawl_directory(path)
if not cameras:
    print("Warning: No Lensfun database found.")


class FieldNotFoundError(Exception):
    pass


class NoLCPDataUsed(Exception):
    pass


class NoFieldDefault:
    pass


camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
unusable_lens_name_regex = re.compile("[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)


class LCPLens:

    def __init__(self, filepath):
        self.tree = ElementTree.parse(filepath)
        self.old_format = bool(
            self.tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in self.tree.getroot()[0][0][0][0]]
        self._read_first_entry()
        self._fix_focal_lengths()
        self.xml_element = self.xml_element()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def _fix_focal_lengths(self):
        """For now, I just delete entries with a missing FocalLength field."""
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                focal_length = float(self.read_field(entry, "FocalLength"))
            except FieldNotFoundError:
                print("Error!")
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries
            
    def _read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        camera_model = self.read_field(entry, "Model", camera_make)
        camera = cameras.get((camera_make.lower(), camera_model.lower()))
        self.model_en = self.read_field(entry, "LensPrettyName")
        self.maker = self.model_en.split()[0]
        try:
            self.model = self.read_field(entry, "Lens")
        except FieldNotFoundError:
            self.model = self.model_en
        if unusable_lens_name_regex.match(self.model):
            self.model = self.model_en
#        print(self.model_en, (50 - len(self.model_en)) * " ", self.model)
        try:
            self.cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            self.cropfactor = camera and camera.cropfactor or 1
        models = [self.model] if self.model == self.model_en else [self.model, self.model_en]
        for lens in lenses:
            if lens.matches(models, self.cropfactor):
                self.lensfun_lens = lens
                self.maker = child_without_attributes(lens.element, "maker").text
                self.model = child_without_attributes(lens.element, "model").text
#                print("Match! (1)")
                break
        else:
#            print("No Match! (2)")
            self.lensfun_lens = None
        if camera and camera.mount[0].islower():
            self.fixed_lens_mount = camera.mount
        else:
            self.fixed_lens_mount = None
        
    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    def best_entries(self, tca):
        """Return the entries best suited for distortion and TCA data, because Lensfun
        can only use one per focal length."""
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).\
               find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -1)
            current_aperture = current_apertures.setdefault(focal_length, 1000)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("distortion", {"focal": str(focal_length), "model": "acm"})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("tca", {"focal": str(focal_length), "model": "acm"})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else
                                                            "ChromaticBlueGreenModel"))
                scale_factor = self.read_field(chromatic_element, "ScaleFactor", None)
                if scale_factor is not None:
                    element.attrib[type_ + "0"] = scale_factor
                for i in range(1, 6):
                    parameter = self.read_field(chromatic_element, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        match = re.search(r"f/?(?P<min>[0-9.]+)", self.model, re.IGNORECASE)
        if match:
            aperture_min = float(match.group("min"))
        else:
            aperture_min = 0
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue", "nan"))
            distance = float(self.read_field(entry, "FocusDistance", "nan"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            focal_length = self.read_field(entry, "FocalLength")
            try:
                aperture = self.read_field(entry, "ApertureValue")
                distance = self.read_field(entry, "FocusDistance")
            except FieldNotFoundError:
                continue
            if aperture_min > float(aperture):
                continue
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = self.get_description_element_maybe(entry)
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    entry = self.get_description_element_maybe(entry)
                    element = ElementTree.Element("vignetting", {"focal": focal_length, "model": "acm", "aperture": aperture,
                                                                 "distance": distance})
                    for i in range(1, 6):
                        α = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if α is not None:
                            element.attrib["alpha{}".format(i)] = α
                    elements.append(element)
        return elements

    def guess_ilc_mounts(self):
        maker = self.maker.lower()
        model = self.model.lower()
        mounts = set()
        if "nikon" in maker:
            if 2.6 < self.cropfactor < 2.8:
                mounts.add("Nikon CX")
            else:
                mounts.add("Nikon F AF")
        if "canon" in maker:
            if "ef-m" in model:
                mounts.add("Canon EF-M")
            else:
                mounts.add("Canon EF")
        if "sony" in maker:
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.add("Sony Alpha")
        if "sigma" in maker:
            if "E " in self.model:
                mounts.add("Sony E")
            else:
                mounts.update({"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD",
                               "Olympus OM", "4/3 System"})
        if "tokina" in maker:
            mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Canon FD", "Minolta M", "Olympus OM"})
        if "tamron" in maker:
            mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        if not mounts:
            mounts = {"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD",
                      "Olympus OM", "4/3 System"}
        result = []
        for mount in mounts:
            element = ElementTree.Element("mount")
            element.text = mount
            result.append(element)
        return result

    def xml_element(self):
        if self.lensfun_lens:
            lens = copy.deepcopy(self.lensfun_lens.element)
            calibration = lens.find("calibration")
            if calibration is None:
                calibration = ElementTree.SubElement(lens, "calibration")
            self.correction_coverage = 3
            lcp_entries_used = False
            if calibration.find("distortion") is None:
                entries, fisheye = self.generate_distortion_entries()
                if fisheye:
                    type_ = lens.find("type")
                    if type_ is not None:
                        if type_.text != "fisheye":
                            entries = []
                    else:
                        type_element = ElementTree.Element("type")
                        type_element.text = "fisheye"
                        lens.insert(max(len(lens) - 1, 0), type_element)
                if entries:
                    calibration.extend(entries)
                    lcp_entries_used = True
                else:
                    self.correction_coverage -= 1
            if calibration.find("tca") is None:
                entries = self.generate_tca_entries()
                if entries:
                    calibration.extend(entries)
                    lcp_entries_used = True
                else:
                    self.correction_coverage -= 1
            if calibration.find("vignetting") is None:
                entries = self.generate_vignetting_entries()
                if entries:
                    calibration.extend(entries)
                    lcp_entries_used = True
                else:
                    self.correction_coverage -= 1
            if not lcp_entries_used:
                raise NoLCPDataUsed
        else:
            lens = ElementTree.Element("lens")
            ElementTree.SubElement(lens, "maker").text = self.maker
            ElementTree.SubElement(lens, "model").text = self.model
            if self.model != self.model_en:
                ElementTree.SubElement(lens, "model", {"lang": "en"}).text = self.model_en
            if self.fixed_lens_mount:
                ElementTree.SubElement(lens, "mount").text = self.fixed_lens_mount
            else:
                lens.extend(self.guess_ilc_mounts())
            ElementTree.SubElement(lens, "cropfactor").text = str(self.cropfactor)
            self.correction_coverage = 0
            entries, fisheye = self.generate_distortion_entries()
            if fisheye:
                ElementTree.SubElement(lens, "type").text = "fisheye"
            calibration = ElementTree.SubElement(lens, "calibration")
            if entries:
                calibration.extend(entries)
                self.correction_coverage += 1
            entries = self.generate_tca_entries()
            if entries:
                calibration.extend(entries)
                self.correction_coverage += 1
            entries = self.generate_vignetting_entries()
            if entries:
                calibration.extend(entries)
                self.correction_coverage += 1
        return lens

    @property
    def normalized_cropfactor(self):
        if 1.5 <= self.cropfactor <= 1.57:
            return 1.5
        elif 1.58 <= self.cropfactor <= 1.63:
            return 1.6
        elif 1.2 <= self.cropfactor <= 1.3:
            return 1.3
        else:
            return round(self.cropfactor * 10) / 10


lcp_lenses = {}
for root, __, filenames in os.walk(args.input_directory):
    for filename in filenames:
        filepath = os.path.join(root, filename)
        try:
            lcp_lens = LCPLens(filepath)
        except (ElementTree.ParseError, NoLCPDataUsed):
            continue
#        print(filepath)
        key = (lcp_lens.maker, lcp_lens.model, lcp_lens.normalized_cropfactor)
        already_existing_lens = lcp_lenses.get(key)
        if not already_existing_lens or already_existing_lens.correction_coverage < lcp_lens.correction_coverage \
           or already_existing_lens.correction_coverage == lcp_lens.correction_coverage and \
           already_existing_lens.cropfactor > lcp_lens.cropfactor:
            lcp_lenses[key] = lcp_lens


output = ElementTree.Element("lensdatabase", {"version": "2"})
for lens in lcp_lenses.values():
    output.append(lens.xml_element)
indent(output)
output.text = "\n\n    "
output.tail = "\n"
output[-1].tail = "\n\n"
open(args.output, "w").write(ElementTree.tostring(output, encoding="unicode"))
